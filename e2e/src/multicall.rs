use alloc::vec::Vec;
use core::str::from_utf8;
use fluentbase_codec::SolidityABI;
use fluentbase_sdk::{address, compile_wasm_to_rwasm, Address, Bytes};
use fluentbase_sdk_testing::EvmTestingContext;
use hex_literal::hex;

#[test]
fn test_multicall_greeting() {
    let mut ctx = EvmTestingContext::default();
    const EXAMPLE_GREETING_ADDRESS: Address = address!("2222222222222222222222222222222222222222");
    let greeting_rwasm = compile_wasm_to_rwasm(crate::EXAMPLE_GREETING).unwrap();
    ctx.add_bytecode(EXAMPLE_GREETING_ADDRESS, greeting_rwasm.rwasm_bytecode);
    const DEPLOYER_ADDRESS: Address = address!("1231238908230948230948209348203984029834");
    let multicall_input: Bytes = hex!("ac9650d800000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000000445773e4e00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000445773e4e00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000445773e4e00000000000000000000000000000000000000000000000000000000").into();
    let result = ctx.call_evm_tx(
        DEPLOYER_ADDRESS,
        EXAMPLE_GREETING_ADDRESS,
        multicall_input,
        Some(300_000_000),
        None,
    );
    assert!(result.is_success(), "failed to call evm ({:?})", result);
    let output = result.output().unwrap_or_default();
    println!("Decoded output: {:?}", from_utf8(&output[68..]));
    assert!(result.is_success());
    let expected_output = hex!(
        "00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000000c48656c6c6f2c20576f726c640000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c48656c6c6f2c20576f726c640000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c48656c6c6f2c20576f726c640000000000000000000000000000000000000000");
    assert_eq!(hex::encode(expected_output), hex::encode(output));
}

#[test]
fn test_multicall() {
    let mut ctx = EvmTestingContext::default();
    const DEPLOYER_ADDRESS: Address = address!("1231238908230948230948209348203984029834");

    // Deploy contract that we'll call through multicall
    let contract_address =
        ctx.deploy_evm_tx(DEPLOYER_ADDRESS, crate::EXAMPLE_ROUTER_SOLIDITY.into());
    println!(
        "Solidity router contract deployed at: {:?}",
        contract_address
    );

    // Call multiple functions in the contract router-solidity
    // greeting(Hello, World!)
    // customGreeting(Custom Hello, World!)
    let multicall_input = hex::decode(
        "ac9650d800000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000064f8194e480000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000e48656c6c6f2c20576f726c64212100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006436b83a9a00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000015437573746f6d2048656c6c6f2c20576f726c642121000000000000000000000000000000000000000000000000000000000000000000000000000000"
    ).unwrap();

    let result = ctx.call_evm_tx(
        DEPLOYER_ADDRESS,
        contract_address,
        multicall_input.clone().into(),
        Some(300_000_000),
        None,
    );

    if !result.is_success() {
        if let Ok(output_str) = from_utf8(&result.output().unwrap_or_default().to_vec()[68..]) {
            println!("Decoded output: {}", output_str);
        }
        panic!("Multicall failed: {:?}", result);
    }

    let expected_output = hex::decode(
        "00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000e48656c6c6f2c20576f726c642121000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000015437573746f6d2048656c6c6f2c20576f726c6421210000000000000000000000").unwrap();

    let output = result.output().unwrap();

    assert_eq!(hex::encode(&expected_output[..]), hex::encode(output));
}

#[test]
fn decode_input() {
    let input = hex::decode("ac9650d800000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000064f8194e480000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000d48656c6c6f2c20576f726c64210000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006436b83a9a00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000014437573746f6d2048656c6c6f2c20576f726c642100000000000000000000000000000000000000000000000000000000000000000000000000000000").unwrap();

    let input = Bytes::from(input);
    println!("Input: {:?}", hex::encode(&input));
    let inputs: Vec<Bytes> =
        SolidityABI::decode(&&input[4..], 0).expect("failed to decode multicall inputs");

    println!("Multicall inputs: {:?}", inputs);
}

#[test]
fn decode_output() {
    let output = hex::decode(
        "00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000e48656c6c6f2c20576f726c642121000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000015437573746f6d2048656c6c6f2c20576f726c6421210000000000000000000000").unwrap();

    let ouputs: Vec<Bytes> = SolidityABI::decode(&&output[..], 0).unwrap();
    let expected_results = vec![
        "Hello, World!!".to_string(),
        "Custom Hello, World!!".to_string(),
    ];

    let mut results: Vec<String> = vec![];

    for (_, output) in ouputs.iter().enumerate() {
        let decoded: String = SolidityABI::decode(output, 0).unwrap();
        results.push(decoded);
    }

    assert_eq!(results, expected_results);
}

#[test]
#[should_panic(expected = "Multicall failed")]
fn test_multicall_invalid_method() {
    let mut ctx = EvmTestingContext::default();
    const DEPLOYER_ADDRESS: Address = address!("1231238908230948230948209348203984029834");

    // Deploy contract that we'll call through multicall
    let contract_address =
        ctx.deploy_evm_tx(DEPLOYER_ADDRESS, crate::EXAMPLE_ROUTER_SOLIDITY.into());
    println!(
        "Solidity router contract deployed at: {:?}",
        contract_address
    );

    // Call multiple functions including an invalid one:
    // 1. greeting(Hello, World!) - valid
    // 2. nonExistentMethod() - invalid method
    let multicall_input = hex::decode(
        "ac9650d800000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000064f8194e480000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000e48656c6c6f2c20576f726c64212100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004abcdef000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000000"
    ).unwrap();

    let result = ctx.call_evm_tx(
        DEPLOYER_ADDRESS,
        contract_address,
        multicall_input.clone().into(),
        Some(300_000_000),
        None,
    );

    if !result.is_success() {
        if let Ok(output_str) = String::from_utf8(result.output().unwrap_or_default().to_vec()) {
            println!("Decoded output: {}", output_str);
        }
        panic!("Multicall failed: {:?}", result);
    }

    // We should never reach this point as the test should panic
    assert!(
        false,
        "Test should have panicked due to invalid method call"
    );
}
