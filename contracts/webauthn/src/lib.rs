#![cfg_attr(target_arch = "wasm32", no_std)]
extern crate alloc;

use fluentbase_sdk::{alloc_slice, func_entrypoint, SharedAPI};

mod params;
mod utils;
mod webauthn;

use params::parse_webauthn_params;
use webauthn::{verify_p256_signature, verify_webauthn};

const VERIFY_P256_SIGNATURE_SELECTOR: [u8; 4] = [0xc3, 0x58, 0x91, 0x0e];

const VERIFY_WEBAUTHN_SELECTOR: [u8; 4] = [0xbc, 0xcf, 0x2a, 0xb7];

pub fn main(mut sdk: impl SharedAPI) {
    let input_length = sdk.input_size();
    assert!(input_length >= 4, "webauthn: insufficient input length");

    let mut input = alloc_slice(input_length as usize);
    sdk.read(&mut input, 0);

    let (selector, params) = input.split_at(4);

    let is_valid = if selector == VERIFY_P256_SIGNATURE_SELECTOR {
        handle_p256_verification(params)
    } else if selector == VERIFY_WEBAUTHN_SELECTOR {
        handle_webauthn_verification(params)
    } else {
        panic!("webauthn: invalid method selector");
    };

    let mut output = [0u8; 32];

    if is_valid {
        output[31] = 1;
    }

    sdk.write(&output);
}

fn handle_p256_verification(params: &[u8]) -> bool {
    // Ensure we have sufficient data (5 * 32 bytes for parameters)
    if params.len() < 160 {
        return false;
    }

    verify_p256_signature(
        &utils::array_from_slice(&params[0..32]),    // message_hash
        &utils::array_from_slice(&params[32..64]),   // r
        &utils::array_from_slice(&params[64..96]),   // s
        &utils::array_from_slice(&params[96..128]),  // x
        &utils::array_from_slice(&params[128..160]), // y
        true,
    )
}

fn handle_webauthn_verification(params: &[u8]) -> bool {
    match parse_webauthn_params(params) {
        Some(parsed_params) => verify_webauthn(&parsed_params),
        None => false,
    }
}

func_entrypoint!(main);
#[cfg(test)]
mod tests {
    use super::*;
    use fluentbase_sdk::{testing::TestingContext, Bytes, ContractContextV1};

    fn exec_precompile(inputs: &[u8], expected_result: bool) {
        let gas_limit = 100_000;
        let sdk = TestingContext::default()
            .with_input(Bytes::copy_from_slice(inputs))
            .with_contract_context(ContractContextV1 {
                gas_limit,
                ..Default::default()
            });

        let sdk_clone = sdk.clone();
        main(sdk);

        let output = sdk_clone.take_output();

        let mut expected = [0u8; 32];
        if expected_result {
            expected[31] = 1;
        }

        assert_eq!(output, expected, "Verification result mismatch");
    }

    #[test]
    fn test_verify_p256_signature_call() {
        let valid_signature= hex::decode("c358910ec0719e9a8d5d838d861dc6f675c899d2b309a3a65bb9fe6b11e5afcbf9a2c0b13d5276691679b5f129221bdf9fdbe5e28cff2cc78212e803bef366ca80b2a99f6687426a737b6a560a43879564c82b2bdcfed64566c99b11db4188b0895142b9e8fb1e80a7ca4e744925d7d71d0a644148ab746e1ed77be2b78b9cd1b4e9b0981065e5b3319e8934646e9ef9c2c52854b575c745ea672638496076bb1a9c49b6").unwrap();

        exec_precompile(&valid_signature, true);
    }

    #[test]
    fn test_verify_webauthn_call() {
        // signing key "9760033113d4a4a8dbb642f467447032f6233166171f0cb9fe82a1a48122e728"
        // verifying key
        // "04b14907bf4c57c15a70f28f34ebfbe5d838d94799c14700406b2409853284d40bcbd5a2dfb95257c542e3c3a65e93bc7ff3f3f4d7db2a4ffa73f1e960549321bd"
        // challenge "5465737420576562417574686e204368616c6c656e6765"
        // auth_data "49960de5880e8c687434170f6476605b8fe4aeb9a28632c7995cf3ba831d97630500000101"
        // client_data_json "{\"type\":\"webauthn.get\",\"challenge\":\"VGVzdCBXZWJBdXRobiBDaGFsbGVuZ2U\",\"origin\":\"http://localhost\"}"
        // client_data_json_bytes
        // "7b2274797065223a22776562617574686e2e676574222c226368616c6c656e6765223a225647567a644342585a574a426458526f6269424461474673624756755a3255222c226f726967696e223a22687474703a2f2f6c6f63616c686f7374227d"
        // challenge_location 23
        // r_u256 1111194438401267428442995897276271052550093708172800581849125926909391163190
        // s_u256 22888161708663110802946977475433471188440031263488037091149311773765989817009
        // x_u256 80188407504581048355539915070575887722882704914511561138372828576030677849099
        // y_u256 92196970801693807391859472966720739524828324683772226580046826715059233956285
        // encoded "00000000000000000000000000000000000000000000000000000000000001400000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000018000000000000000000000000000000000000000000000000000000000000001e0000000000000000000000000000000000000000000000000000000000000001700000000000000000000000000000000000000000000000000000000000000010274e9ec748cfdda994d791452e9bb83c9cba720af55856056ae7619c1b04f36329a3d8de084133df57bce149a36428c8b41b9e06af6a7e7030c4a4d712fdab1b14907bf4c57c15a70f28f34ebfbe5d838d94799c14700406b2409853284d40bcbd5a2dfb95257c542e3c3a65e93bc7ff3f3f4d7db2a4ffa73f1e960549321bd00000000000000000000000000000000000000000000000000000000000000175465737420576562417574686e204368616c6c656e6765000000000000000000000000000000000000000000000000000000000000000000000000000000002549960de5880e8c687434170f6476605b8fe4aeb9a28632c7995cf3ba831d9763050000010100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000617b2274797065223a22776562617574686e2e676574222c226368616c6c656e6765223a225647567a644342585a574a426458526f6269424461474673624756755a3255222c226f726967696e223a22687474703a2f2f6c6f63616c686f7374227d00000000000000000000000000000000000000000000000000000000000000"
        // Encode parameters using our function
        let input = hex::decode("bccf2ab700000000000000000000000000000000000000000000000000000000000001400000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000018000000000000000000000000000000000000000000000000000000000000001e0000000000000000000000000000000000000000000000000000000000000001700000000000000000000000000000000000000000000000000000000000000010274e9ec748cfdda994d791452e9bb83c9cba720af55856056ae7619c1b04f36329a3d8de084133df57bce149a36428c8b41b9e06af6a7e7030c4a4d712fdab1b14907bf4c57c15a70f28f34ebfbe5d838d94799c14700406b2409853284d40bcbd5a2dfb95257c542e3c3a65e93bc7ff3f3f4d7db2a4ffa73f1e960549321bd00000000000000000000000000000000000000000000000000000000000000175465737420576562417574686e204368616c6c656e6765000000000000000000000000000000000000000000000000000000000000000000000000000000002549960de5880e8c687434170f6476605b8fe4aeb9a28632c7995cf3ba831d9763050000010100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000617b2274797065223a22776562617574686e2e676574222c226368616c6c656e6765223a225647567a644342585a574a426458526f6269424461474673624756755a3255222c226f726967696e223a22687474703a2f2f6c6f63616c686f7374227d00000000000000000000000000000000000000000000000000000000000000").unwrap();

        // Execute precompile
        exec_precompile(&input, true);
    }
}
