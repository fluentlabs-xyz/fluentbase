#![cfg_attr(target_arch = "wasm32", no_std)]

mod bytecode;
mod evm;
#[cfg(test)]
mod tests;
mod utils;

extern crate alloc;
extern crate core;
extern crate fluentbase_sdk;

use crate::{
    bytecode::{commit_evm_bytecode, load_evm_bytecode},
    evm::exec_evm_bytecode,
};
use core::ops::Neg;
use fluentbase_sdk::{func_entrypoint, Bytes, ContractContextReader, ExitCode, SharedAPI};
use revm_interpreter::{
    gas,
    primitives::Bytecode,
    return_ok,
    return_revert,
    InstructionResult,
    InterpreterResult,
    MAX_CODE_SIZE,
};

/// Handles non-OK results from the EVM interpreter.
///
/// This function performs the following:
/// 1. Synchronizes the remaining and refunded gas with the `SharedAPI` instance.
/// 2. Write the output of the interpreter result to the `SharedAPI` instance.
/// 3. If the result is a revert, immediately exits with a panic exit code.
/// 4. Determine the final exit code based on the `InstructionResult` value and exits accordingly.
///
/// ## Parameters:
/// - `sdk`: A mutable instance of a type implementing the `SharedAPI` trait to interface with the
///   environment.
/// - `result`: The `InterpreterResult` containing the gas usage, output, and result status.
///
/// ## Exit Codes:
/// - `ExitCode::Ok` (0) for successful instructions.
/// - `ExitCode::Panic` (-1) for revert cases.
/// - `ExitCode::Err` (-2) for any other error conditions.
///
/// By interpreting and mapping results appropriately, this function ensures
/// the correct handling and propagation of results from the EVM context.
fn handle_not_ok_result<SDK: SharedAPI>(mut sdk: SDK, result: InterpreterResult) {
    sdk.sync_evm_gas(result.gas.remaining(), result.gas.refunded());
    sdk.write(result.output.as_ref());
    if result.is_revert() {
        sdk.exit(ExitCode::Panic.into_i32());
    }
    let exit_code = match result.result {
        return_ok!() => ExitCode::Ok,
        return_revert!() => ExitCode::Panic,
        _ => ExitCode::Err,
    };
    sdk.exit(exit_code.into_i32());
}

/// Deploys an EVM smart contract using the provided bytecode input.
///
/// This function handles the deployment process for EVM-compatible smart contracts,
/// including executing the contract bytecode, ensuring compliance with EVM specifications,
/// and committing the deployed bytecode if the deployment is successful.
///
/// # Steps:
/// 1. **Fetch Input and Context**:
///    - Retrieves the input bytecode for contract deployment using the SDK.
///    - Obtains the gas limit for the deployment from the context.
///
/// 2. **Execute EVM Bytecode**:
///    - Executes the provided bytecode via the `exec_evm_bytecode` function.
///    - If the execution fails, the non-success result is processed by `handle_not_ok_result` and
///      the function terminates early.
///
/// 3. **EIP-3541 (Disallow Code Starting with 0xEF)**:
///    - Checks if the executed contract output begins with the byte `0xEF` (non-standard prefix).
///    - If so, exits with the error code `InstructionResult::CreateContractStartingWithEF`.
///
/// 4. **EIP-170 (Code Size Limit)**:
///    - Verifies if the length of the generated bytecode exceeds 24KB, specified by
///      `MAX_CODE_SIZE`.
///    - Exits with `InstructionResult::CreateContractSizeLimit` error if the limit is exceeded.
///
/// 5. **Gas Cost for Code Deposit**:
///    - Calculates the gas cost for storing the deployed bytecode based on `CODEDEPOSIT` (a
///      predefined gas constant) and the bytecode size.
///    - If the cost cannot be recorded (due to insufficient gas), charge the maximum fuel and exits
///      accordingly.
///
/// 6. **Synchronize Gas Information**:
///    - Updates the EVM gas state (remaining and refunded gas) in the SDK to keep it synchronized
///      with the deployment process.
///
/// 7. **Commit Bytecode**:
///    - Saves the deployed contract bytecode to persistent storage using `commit_evm_bytecode`.
///
/// This function ensures compatibility with fundamental Ethereum standards and handles
/// gas calculations, runtime checks, and storage updates as part of the deployment flow.
///
/// # Parameters
/// - `sdk`: A mutable reference to the SDK instance that implements the `SharedAPI` trait.
///
/// # Errors
/// The function can exit under various error conditions:
/// - Non-successful EVM bytecode execution.
/// - Code starting with 0xEF (EIP-3541 violation).
/// - Code exceeding the size limit (EIP-170 violation).
/// - Insufficient gas for code deposit.
///
/// # Gas Mechanics
/// - Gas is deducted during the bytecode execution and additional deployment steps.
/// - Compatibility with EVM gas mechanisms is maintained to ensure Ethereum-like behavior.
pub fn deploy<SDK: SharedAPI>(mut sdk: SDK) {
    let input: Bytes = sdk.input().into();
    let gas_limit = sdk.context().contract_gas_limit();

    let mut result = exec_evm_bytecode(
        &mut sdk,
        Bytecode::new_raw(input),
        Bytes::default(),
        gas_limit,
    );
    if !result.is_ok() {
        return handle_not_ok_result(sdk, result);
    }

    // EIP-3541 and EIP-170 checks
    if result.output.first() == Some(&0xEF) {
        sdk.exit((InstructionResult::CreateContractStartingWithEF as i32).neg());
    } else if result.output.len() > MAX_CODE_SIZE {
        sdk.exit((InstructionResult::CreateContractSizeLimit as i32).neg());
    }
    let gas_for_code = result.output.len() as u64 * gas::CODEDEPOSIT;
    if !result.gas.record_cost(gas_for_code) {
        sdk.charge_fuel(u64::MAX);
    }

    sdk.sync_evm_gas(result.gas.remaining(), result.gas.refunded());
    // we intentionally don't charge gas for these opcodes
    // to keep full compatibility with an EVM deployment process
    commit_evm_bytecode(&mut sdk, result.output);
}

/// The main entry point function of the application that processes EVM-based contract bytecode.
///
/// This function interacts with an environment (`SharedAPI`) to execute EVM bytecode
/// with input data under a specified gas limit.
/// The results are then processed, handled, and written back to the environment.
///
/// ### Key Steps:
/// 1. Load the EVM bytecode for the specific contract using `load_evm_bytecode`.
///    - If the bytecode is not available (e.g., invalid or absent), the function terminates early.
/// 2. Retrieve the input data provided by the environment via `sdk.input()`.
/// 3. Fetch the gas limit for the contract execution from the environment's `contract_gas_limit`.
/// 4. Execute EVM bytecode with `exec_evm_bytecode`, passing:
///    - Loaded bytecode
///    - Input data
///    - Gas limit
/// 5. Check the result of the execution:
///    - If unsuccessful, handle the failure gracefully using `handle_not_ok_result`.
///    - If successful, sync gas usage (`remaining` and `refunded` gas) via `sdk.sync_evm_gas`, and
///      write the execution output back with `sdk.write`.
///
/// ### Parameters:
/// - `sdk`: An instance implementing `SharedAPI` to provide runtime functionality, such as
///   input/output handling, gas synchronization, and context details.
///
/// ### Detailed Behavior:
/// This function ensures that gas usage and execution outputs are synchronously managed
/// between the SDK environment and the virtual machine.
/// The error-handling mechanism ensures
/// that non-successful results terminate the function with appropriate actions, such as panic
/// (`revert`) or error logging.
///
/// ### Assumptions:
/// - The SDK instance conforms to the `SharedAPI` interface.
/// - Bytecode is preloaded and valid for the specific context where the function is executed.
pub fn main<SDK: SharedAPI>(mut sdk: SDK) {
    let Some(evm_bytecode) = load_evm_bytecode(&sdk) else {
        return;
    };

    let input: Bytes = sdk.input().into();
    let gas_limit = sdk.context().contract_gas_limit();

    let result = exec_evm_bytecode(&mut sdk, evm_bytecode, input, gas_limit);
    if !result.is_ok() {
        return handle_not_ok_result(sdk, result);
    }

    sdk.sync_evm_gas(result.gas.remaining(), result.gas.refunded());
    sdk.write(result.output.as_ref());
}

func_entrypoint!(main, deploy);
