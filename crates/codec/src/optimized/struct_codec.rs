
use crate::optimized::{ctx::EncodingContext, encoder::Encoder, error::CodecError};
use byteorder::BigEndian;
use bytes::{Buf, BufMut};

//// Compact ABI encoding for structs
/// CompactABI layout for `Example { nums: Vec<Vec<u32>>, age: u32, tags: Vec<u8> }`
///
/// ┌───────────── HEADER SECTION (little-endian, 4-byte aligned) ─────────────┐
/// │ #0  nums.len   nums.off   nums.size      ← header of outer Vec           │
/// │ #1  inner0.len inner0.off inner0.size    ← header of first  inner Vec    │
/// │ #2  inner1.len inner1.off inner1.size    ← header of second inner Vec    │
/// │ age (u32)                         ← static field, *after* all vecs heads │
/// │ #3  tags.len   tags.off   tags.size      ← header of second dynamic Vec  │
/// └──────────────────────────────────────────────────────────────────────────┘
/// ┌────────────── BODY SECTION (same DFS order, 4-byte aligned) ─────────────┐
/// │ inner0 data  [u32 ...]                                                   │
/// │ inner1 data  [u32 ...]                                                   │
/// │ tags data   [u8 ...]                                                    │
/// └──────────────────────────────────────────────────────────────────────────┘
///
/// • Headers are written in DFS-preorder: "own header → children's headers"
/// • All static fields of the struct are placed immediately after the last header
/// • All dynamic fields (even flat ones like Vec<u8>) are encoded with full headers
/// • Bodies (raw data) start only after the complete header section
///   This allows WASM code to read **all** metadata in a single read,
///   without touching the data bodies
///
/// Hex layout for `Example { nums: [[10, 20], [30]], age: 99, tags: vec![1, 2] }`
///
/// 00000000 – nums.len        = 2         // #elements in outer Vec
/// 00000004 – nums.off        = 40        // relative to start-of-body (0x28)
/// 00000008 – nums.size       = 12        // total bytes of both inner Vec bodies
///
/// 0000000C – nums[0].len     = 2         // inner0: two u32 values
/// 00000010 – nums[0].off     = 0         // begins at body+0
/// 00000014 – nums[0].size    = 8         // 2 × 4-byte u32
///
/// 00000018 – nums[1].len     = 1         // inner1: one u32 value
/// 0000001C – nums[1].off     = 8         // begins at body+8 (after inner0)
/// 00000020 – nums[1].size    = 4         // 1 × 4-byte u32
///
/// 00000024 – age             = 99        // static field, placed after all headers
///
/// 00000028 – tags.len        = 2         // flat vec<u8>
/// 0000002C – tags.off        = 16        // offset to [1, 2] (starts at 0x38)
/// 00000030 – tags.size       = 2         // size = 2 bytes
///
/// 00000034 – 0A 00 00 00                 // nums[0] data[0] = 10
/// 00000038 – 14 00 00 00                 // nums[0] data[1] = 20
/// 0000003C – 1E 00 00 00                 // nums[1] data[0] = 30
/// 00000040 – 01 00 00 00                 // tags[0] = 1
/// 00000044 – 01 00 00 00                 // tags[1] = 2
///
/// ↓ Below is the code that will be generated by the derive macro

struct Example {
    nums: Vec<Vec<u32>>,
    age: u32,
    tags: Vec<u8>,
}
// data layout

// nums_header, nums_header0, nums_headerN, age, tags_header || nums_header0_data, nums_headerN_data, tags_header_data

// offsets

// nums_header:
//     len = 2 (outer Vec length)
//     offset ? (to first inner Vec header || to data section)
//     size ? (first inner Vec header size || full size of data Vec<Vec<u32>> )


//  let test_value: Vec<Vec<Vec<u32>>> = vec![vec![vec![1, 2, 3], vec![4, 5], vec![6, 7, 8, 9, 10]]];
// let expected_encoded = hex::decode(concat!(
// // Main array header
// ------------ container start
// "03000000", // length (3)
// "0c000000", // offset to first vector
// "4c000000", // offset to second vector
// ------------ // First vector header
// // First vector [1,2,3] 
// "03000000", // length 
// "24000000", // relative offset
// "0c000000", // data offset
// ------------

// // Second vector [4,5]
// "02000000", // length
// "30000000", // relative offset
// "08000000", // data offset
// ------------
// // Third vector [6,7,8,9,10]
// "05000000", // length
// "38000000", // relative offset since Main array header
// "14000000", // data offset
// ------------
// // Data sections
// "01000000", // 1
// "02000000", // 2
// "03000000", // 3
// "04000000", // 4
// "05000000", // 5
// "06000000", // 6
// "07000000", // 7
// "08000000", // 8
// "09000000", // 9
// "0a000000"  // 10
// ))
// .unwrap();

// maps offsets [keys] [values] - independent || related?
// let expected_encoded = hex::decode(concat!(
// // Header
// "03000000", // length (3 pairs)
// "14000000", // keys_offset (20)
// "0c000000", // keys_size (12)
// "20000000", // values_offset (32)
// "0c000000", // values_size (12)
// // Keys (sorted)
// "03000000", // key = 3
// "64000000", // key = 100
// "e8030000", // key = 1000
// // Values (in same order as keys)
// "05000000", // value = 5
// "14000000", // value = 20
// "3c000000"  // value = 60
// ))
// .unwrap();

impl Encoder<BigEndian, 4, true> for Example {
    type Ctx = EncodingContext;
    const IS_DYNAMIC: bool = true;
    const HEADER_SIZE: usize = 8; // Example header size

    fn build_ctx(&self, ctx: &mut Self::Ctx) -> Result<(), CodecError> {
        // calc length for each level of the dynamic fields and size for the raw data
        <Vec<Vec<u32>> as Encoder<BigEndian, 4, true>>::build_ctx(&self.nums, ctx)?;
        // age is static, so it will early return
        <u32 as Encoder<BigEndian, 4, true>>::build_ctx(&self.age, ctx)?;

        <Vec<u8> as Encoder<BigEndian, 4, true>>::build_ctx(&self.tags, ctx)?;
        Ok(())
    }

    // encode static fields and offsets for the dynamic fields (calculated in `build_ctx`)
    fn encode_header(&self, out: &mut impl BufMut, ctx: &mut EncodingContext) -> Result<usize, CodecError> {
        let mut written = 0;
        let mut offset = 0; // Offset within body section
        let mut node = 0; // Index in context.nodes

        // --- Outer vector (nums) ---
        let meta = ctx.nodes[node]; node += 1;
        out.put_u32_le(meta.len);   written += 4;
        out.put_u32_le(offset);     written += 4;
        out.put_u32_le(meta.tail);  written += 4;
        offset += meta.tail;

        // --- Inner vectors (nums[i]) ---
        for _ in 0..meta.len {
            let m = ctx.nodes[node]; node += 1;
            out.put_u32_le(m.len);   written += 4;
            out.put_u32_le(m.tail);  written += 4;
            out.put_u32_le(m.tail);  written += 4;
        }

        // --- Static field ---
        out.put_u32_le(self.age);   written += 4;

        // --- tags vec<u8> ---
        let meta = ctx.nodes[node]; node += 1;
        out.put_u32_le(meta.len);   written += 4;
        out.put_u32_le(offset);     written += 4;
        out.put_u32_le(meta.tail);  written += 4;
        offset += meta.tail;

        Ok(written)
    }

    // encode dynamic fields like raw data
    fn encode_tail(&self, out: &mut impl bytes::BufMut) -> Result<usize, CodecError> {
        let mut written = 0;
        // actually encode the dynamic fields (only fields without any metadata)
        written += <Vec<Vec<u32>> as Encoder<BigEndian, 4, true>>::encode_tail(&self.nums, out)?;

        // u32 - should be written inside the encode header
        written += <u32 as Encoder<BigEndian, 4, true>>::encode_tail(&self.age, out)?;

        Ok(written)
    }

    fn decode(buf: &impl Buf, offset: usize) -> Result<Self, CodecError> {
        todo!()
    }
}
