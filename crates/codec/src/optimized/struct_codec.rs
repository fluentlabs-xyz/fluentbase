
use crate::optimized::{ctx::EncodingContext, encoder::Encoder, error::CodecError};
use byteorder::BigEndian;
use bytes::Buf;

/// Compact ABI encoding for structs
/// CompactABI layout for `Example { nums: Vec<Vec<u32>>, age: u32 }`
///
/// ┌───────────── HEADER SECTION (little-endian, 4-byte aligned) ─────────────┐
/// │ #0  nums.len   nums.off   nums.size      ← header of outer Vec           │
/// │ #1  inner0.len inner0.off inner0.size    ← header of first  inner Vec    │
/// │ #2  inner1.len inner1.off inner1.size    ← header of second inner Vec    │
/// │ age (u32)                         ← static field, *after* all vecs heads │
/// └──────────────────────────────────────────────────────────────────────────┘
/// ┌────────────── BODY SECTION (same DFS order, 4-byte aligned) ─────────────┐
/// │ inner0 data  [u32 ...]                                                   │
/// │ inner1 data  [u32 ...]                                                   │
/// └──────────────────────────────────────────────────────────────────────────┘
///
/// • Headers are written in DFS-preorder: "own header → children's headers"
/// • All static fields of the struct are placed immediately after the last header
/// • Bodies (raw data) start only after the complete header section
///   This allows WASM code to read **all** metadata in a single read,
///   without touching the data bodies
///
/// 00000000 – nums.len        = 2         // #elements in outer Vec
/// 00000004 – nums.off        = 40         // relative to start-of-body (0x28)
/// 00000008 – nums.size       = 12        // total bytes of both inner Vec bodies
/// 
/// 0000000C – nums[0].len     = 2         // inner0: two u32 values
/// 00000010 – nums[0].off     = 0         // begins at body+0
/// 00000014 – nums[0].size    = 8         // 2 × 4-byte u32
/// 
/// 00000018 – nums[1].len     = 1         // inner1: one u32 value
/// 0000001C – nums[1].off     = 8         // begins at body+8  (after inner0)
/// 00000020 – nums[1].size    = 4         // 1 × 4-byte u32
/// 
/// 00000024 – age             = 99        // static field, placed after all headers
/// 
/// 00000028 – 0A 00 00 00                 // nums[0] data[0] = 10
/// 0000002C – 14 00 00 00                 // nums[0] data[1] = 20
/// 00000030 – 1E 00 00 00                 // nums[1] data[0] = 30
/// ↓ Below is the code that will be generated by the derive macro
struct Example {
    nums: Vec<Vec<u32>>,
    age: u32,
}


impl Encoder<BigEndian, 4, true> for Example {
    type Ctx = EncodingContext;
    const IS_DYNAMIC: bool = true;
    const HEADER_SIZE: usize = 8; // Example header size

    fn build_ctx(&self, ctx: &mut Self::Ctx) -> Result<(), CodecError> {
        // calc length for each level of the dynamic fields and size for the raw data
        <Vec<Vec<u32>> as Encoder<BigEndian, 4, true>>::build_ctx(&self.nums, ctx)?;

        // age is static, so it will early return
        <u32 as Encoder<BigEndian, 4, true>>::build_ctx(&self.age, ctx)?;
        Ok(())
    }

    // encode static fields and offsets for the dynamic fields (calculated in `build_ctx`)
    fn encode_header(
        &self,
        out: &mut impl bytes::BufMut,
        ctx: &EncodingContext,
    ) -> Result<usize, CodecError> {
        todo!()
    }

    // encode dynamic fields like raw data
    fn encode_tail(&self, out: &mut impl bytes::BufMut) -> Result<usize, CodecError> {
        let mut written = 0;
        // actually encode the dynamic fields (only fields without any metadata)
        written += <Vec<Vec<u32>> as Encoder<BigEndian, 4, true>>::encode_tail(&self.nums, out)?;

        // u32 - should be written inside the encode header
        written += <u32 as Encoder<BigEndian, 4, true>>::encode_tail(&self.age, out)?;

        Ok(written)
    }

    fn decode(buf: &impl Buf, offset: usize) -> Result<Self, CodecError> {
        todo!()
    }
}
