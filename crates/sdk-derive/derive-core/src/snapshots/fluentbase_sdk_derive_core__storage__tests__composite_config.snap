---
source: crates/sdk-derive/derive-core/src/storage.rs
expression: formatted
---
impl Config {
    pub const REQUIRED_SLOTS: usize = Self::calculate_required_slots();
    pub fn new(slot: fluentbase_sdk::U256, offset: u8) -> Self {
        let mut current_slot = slot;
        let mut current_offset: u8 = offset;
        let owner_layout = {
            let encoded_size = <StoragePrimitive<
                Address,
            > as fluentbase_sdk::storage::StorageLayout>::ENCODED_SIZE as u8;
            let required_slots = <StoragePrimitive<
                Address,
            > as fluentbase_sdk::storage::StorageLayout>::REQUIRED_SLOTS;
            let layout = if required_slots == 0 {
                if current_offset + encoded_size <= 32 {
                    let actual_offset = 32 - current_offset - encoded_size;
                    let result = (current_slot, actual_offset);
                    current_offset += encoded_size;
                    result
                } else {
                    current_slot = current_slot + fluentbase_sdk::U256::from(1);
                    let actual_offset = 32 - encoded_size;
                    current_offset = encoded_size;
                    (current_slot, actual_offset)
                }
            } else {
                if current_offset > 0 {
                    current_slot = current_slot + fluentbase_sdk::U256::from(1);
                    current_offset = 0;
                }
                let result = (current_slot, 0);
                current_slot = current_slot + fluentbase_sdk::U256::from(required_slots);
                current_offset = 0;
                result
            };
            layout
        };
        let version_layout = {
            let encoded_size = <StoragePrimitive<
                u32,
            > as fluentbase_sdk::storage::StorageLayout>::ENCODED_SIZE as u8;
            let required_slots = <StoragePrimitive<
                u32,
            > as fluentbase_sdk::storage::StorageLayout>::REQUIRED_SLOTS;
            let layout = if required_slots == 0 {
                if current_offset + encoded_size <= 32 {
                    let actual_offset = 32 - current_offset - encoded_size;
                    let result = (current_slot, actual_offset);
                    current_offset += encoded_size;
                    result
                } else {
                    current_slot = current_slot + fluentbase_sdk::U256::from(1);
                    let actual_offset = 32 - encoded_size;
                    current_offset = encoded_size;
                    (current_slot, actual_offset)
                }
            } else {
                if current_offset > 0 {
                    current_slot = current_slot + fluentbase_sdk::U256::from(1);
                    current_offset = 0;
                }
                let result = (current_slot, 0);
                current_slot = current_slot + fluentbase_sdk::U256::from(required_slots);
                current_offset = 0;
                result
            };
            layout
        };
        let max_supply_layout = {
            let encoded_size = <StoragePrimitive<
                U256,
            > as fluentbase_sdk::storage::StorageLayout>::ENCODED_SIZE as u8;
            let required_slots = <StoragePrimitive<
                U256,
            > as fluentbase_sdk::storage::StorageLayout>::REQUIRED_SLOTS;
            let layout = if required_slots == 0 {
                if current_offset + encoded_size <= 32 {
                    let actual_offset = 32 - current_offset - encoded_size;
                    let result = (current_slot, actual_offset);
                    current_offset += encoded_size;
                    result
                } else {
                    current_slot = current_slot + fluentbase_sdk::U256::from(1);
                    let actual_offset = 32 - encoded_size;
                    current_offset = encoded_size;
                    (current_slot, actual_offset)
                }
            } else {
                if current_offset > 0 {
                    current_slot = current_slot + fluentbase_sdk::U256::from(1);
                    current_offset = 0;
                }
                let result = (current_slot, 0);
                current_slot = current_slot + fluentbase_sdk::U256::from(required_slots);
                current_offset = 0;
                result
            };
            layout
        };
        Self {
            owner: <<StoragePrimitive<
                Address,
            > as fluentbase_sdk::storage::StorageLayout>::Descriptor as fluentbase_sdk::storage::StorageDescriptor>::new(
                owner_layout.0,
                owner_layout.1,
            ),
            version: <<StoragePrimitive<
                u32,
            > as fluentbase_sdk::storage::StorageLayout>::Descriptor as fluentbase_sdk::storage::StorageDescriptor>::new(
                version_layout.0,
                version_layout.1,
            ),
            max_supply: <<StoragePrimitive<
                U256,
            > as fluentbase_sdk::storage::StorageLayout>::Descriptor as fluentbase_sdk::storage::StorageDescriptor>::new(
                max_supply_layout.0,
                max_supply_layout.1,
            ),
        }
    }
    const fn calculate_required_slots() -> usize {
        let mut current_slot: usize = 0;
        let mut current_offset: usize = 0;
        {
            let encoded_size = <StoragePrimitive<
                Address,
            > as fluentbase_sdk::storage::StorageLayout>::ENCODED_SIZE;
            let required_slots = <StoragePrimitive<
                Address,
            > as fluentbase_sdk::storage::StorageLayout>::REQUIRED_SLOTS;
            if required_slots == 0 {
                if current_offset + encoded_size <= 32 {
                    current_offset += encoded_size;
                } else {
                    current_slot += 1;
                    current_offset = encoded_size;
                }
            } else {
                if current_offset > 0 {
                    current_slot += 1;
                    current_offset = 0;
                }
                current_slot += required_slots;
                current_offset = 0;
            }
        }
        {
            let encoded_size = <StoragePrimitive<
                u32,
            > as fluentbase_sdk::storage::StorageLayout>::ENCODED_SIZE;
            let required_slots = <StoragePrimitive<
                u32,
            > as fluentbase_sdk::storage::StorageLayout>::REQUIRED_SLOTS;
            if required_slots == 0 {
                if current_offset + encoded_size <= 32 {
                    current_offset += encoded_size;
                } else {
                    current_slot += 1;
                    current_offset = encoded_size;
                }
            } else {
                if current_offset > 0 {
                    current_slot += 1;
                    current_offset = 0;
                }
                current_slot += required_slots;
                current_offset = 0;
            }
        }
        {
            let encoded_size = <StoragePrimitive<
                U256,
            > as fluentbase_sdk::storage::StorageLayout>::ENCODED_SIZE;
            let required_slots = <StoragePrimitive<
                U256,
            > as fluentbase_sdk::storage::StorageLayout>::REQUIRED_SLOTS;
            if required_slots == 0 {
                if current_offset + encoded_size <= 32 {
                    current_offset += encoded_size;
                } else {
                    current_slot += 1;
                    current_offset = encoded_size;
                }
            } else {
                if current_offset > 0 {
                    current_slot += 1;
                    current_offset = 0;
                }
                current_slot += required_slots;
                current_offset = 0;
            }
        }
        if current_offset > 0 { current_slot + 1 } else { current_slot }
    }
    ///Returns an accessor for the owner field
    #[inline]
    pub fn owner(
        &self,
    ) -> <StoragePrimitive<
        Address,
    > as fluentbase_sdk::storage::StorageLayout>::Accessor {
        <StoragePrimitive<
            Address,
        > as fluentbase_sdk::storage::StorageLayout>::access(self.owner)
    }
    ///Returns an accessor for the version field
    #[inline]
    pub fn version(
        &self,
    ) -> <StoragePrimitive<u32> as fluentbase_sdk::storage::StorageLayout>::Accessor {
        <StoragePrimitive<
            u32,
        > as fluentbase_sdk::storage::StorageLayout>::access(self.version)
    }
    ///Returns an accessor for the max_supply field
    #[inline]
    pub fn max_supply(
        &self,
    ) -> <StoragePrimitive<U256> as fluentbase_sdk::storage::StorageLayout>::Accessor {
        <StoragePrimitive<
            U256,
        > as fluentbase_sdk::storage::StorageLayout>::access(self.max_supply)
    }
}
impl fluentbase_sdk::storage::composite::CompositeStorage for Config {
    const REQUIRED_SLOTS: usize = Self::REQUIRED_SLOTS;
    fn from_slot(base_slot: fluentbase_sdk::U256) -> Self {
        Self::new(base_slot, 0)
    }
}
