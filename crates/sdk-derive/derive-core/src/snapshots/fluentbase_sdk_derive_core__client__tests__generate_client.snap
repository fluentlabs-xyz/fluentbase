---
source: crates/sdk-derive/derive-core/src/client.rs
expression: formatted_code
---
pub struct TestContractClient<SDK> {
    pub sdk: SDK,
}
pub type FirstMethodCallArgs = (u32,);
pub struct FirstMethodCall(FirstMethodCallArgs);
impl FirstMethodCall {
    pub const SELECTOR: [u8; 4] = [90u8, 193u8, 6u8, 45u8];
    pub const SIGNATURE: &'static str = "firstMethod(uint32)";
    pub fn new(args: FirstMethodCallArgs) -> Self {
        Self(args)
    }
    pub fn encode(&self) -> fluentbase_sdk::codec::bytes::Bytes {
        let mut buf = fluentbase_sdk::codec::bytes::BytesMut::new();
        fluentbase_sdk::codec::encoder::SolidityABI::encode(
                &(self.0.clone().0,),
                &mut buf,
                0,
            )
            .unwrap();
        let encoded_args = buf.freeze();
        let clean_args = if fluentbase_sdk::codec::encoder::SolidityABI::<
            FirstMethodCallArgs,
        >::is_dynamic() {
            encoded_args[32..].to_vec()
        } else {
            encoded_args.to_vec()
        };
        Self::SELECTOR.iter().copied().chain(clean_args).collect()
    }
    pub fn decode(
        buf: &impl fluentbase_sdk::codec::bytes::Buf,
    ) -> ::core::result::Result<Self, fluentbase_sdk::codec::CodecError> {
        use fluentbase_sdk::codec::bytes::BufMut;
        let dynamic_offset = if fluentbase_sdk::codec::encoder::SolidityABI::<
            FirstMethodCallArgs,
        >::is_dynamic() {
            ::fluentbase_sdk::U256::from(32).to_be_bytes::<32>().to_vec()
        } else {
            ::alloc::vec::Vec::new()
        };
        let mut combined_buf = fluentbase_sdk::codec::bytes::BytesMut::new();
        combined_buf.put_slice(&dynamic_offset);
        combined_buf.put_slice(buf.chunk());
        let args = fluentbase_sdk::codec::encoder::SolidityABI::<
            FirstMethodCallArgs,
        >::decode(&combined_buf.freeze(), 0)?;
        Ok(Self(args))
    }
}
impl ::core::ops::Deref for FirstMethodCall {
    type Target = FirstMethodCallArgs;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
pub type FirstMethodCallTarget = <FirstMethodCall as ::core::ops::Deref>::Target;
pub type FirstMethodReturnArgs = (u32,);
#[derive(Debug)]
pub struct FirstMethodReturn(FirstMethodReturnArgs);
impl FirstMethodReturn {
    pub fn new(args: FirstMethodReturnArgs) -> Self {
        Self(args)
    }
    pub fn encode(&self) -> fluentbase_sdk::codec::bytes::Bytes {
        let mut buf = fluentbase_sdk::codec::bytes::BytesMut::new();
        fluentbase_sdk::codec::encoder::SolidityABI::encode(
                &(self.0.clone().0,),
                &mut buf,
                0,
            )
            .unwrap();
        let encoded_args = buf.freeze();
        let clean_args = if fluentbase_sdk::codec::encoder::SolidityABI::<
            FirstMethodReturnArgs,
        >::is_dynamic() {
            encoded_args[32..].to_vec()
        } else {
            encoded_args.to_vec()
        };
        clean_args.into()
    }
    pub fn decode(
        buf: &impl fluentbase_sdk::codec::bytes::Buf,
    ) -> ::core::result::Result<Self, fluentbase_sdk::codec::CodecError> {
        use fluentbase_sdk::codec::bytes::BufMut;
        let dynamic_offset = if fluentbase_sdk::codec::encoder::SolidityABI::<
            FirstMethodReturnArgs,
        >::is_dynamic() {
            ::fluentbase_sdk::U256::from(32).to_be_bytes::<32>().to_vec()
        } else {
            ::alloc::vec::Vec::new()
        };
        let mut combined_buf = fluentbase_sdk::codec::bytes::BytesMut::new();
        combined_buf.put_slice(&dynamic_offset);
        combined_buf.put_slice(buf.chunk());
        let args = fluentbase_sdk::codec::encoder::SolidityABI::<
            FirstMethodReturnArgs,
        >::decode(&combined_buf.freeze(), 0)?;
        Ok(Self(args))
    }
}
impl ::core::ops::Deref for FirstMethodReturn {
    type Target = FirstMethodReturnArgs;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
pub type FirstMethodReturnTarget = <FirstMethodReturn as ::core::ops::Deref>::Target;
pub type SecondMethodCallArgs = (String, bool);
pub struct SecondMethodCall(SecondMethodCallArgs);
impl SecondMethodCall {
    pub const SELECTOR: [u8; 4] = [92u8, 23u8, 35u8, 57u8];
    pub const SIGNATURE: &'static str = "secondMethod(string,bool)";
    pub fn new(args: SecondMethodCallArgs) -> Self {
        Self(args)
    }
    pub fn encode(&self) -> fluentbase_sdk::codec::bytes::Bytes {
        let mut buf = fluentbase_sdk::codec::bytes::BytesMut::new();
        fluentbase_sdk::codec::encoder::SolidityABI::encode(
                &(self.0.clone().0, self.0.clone().1),
                &mut buf,
                0,
            )
            .unwrap();
        let encoded_args = buf.freeze();
        let clean_args = if fluentbase_sdk::codec::encoder::SolidityABI::<
            SecondMethodCallArgs,
        >::is_dynamic() {
            encoded_args[32..].to_vec()
        } else {
            encoded_args.to_vec()
        };
        Self::SELECTOR.iter().copied().chain(clean_args).collect()
    }
    pub fn decode(
        buf: &impl fluentbase_sdk::codec::bytes::Buf,
    ) -> ::core::result::Result<Self, fluentbase_sdk::codec::CodecError> {
        use fluentbase_sdk::codec::bytes::BufMut;
        let dynamic_offset = if fluentbase_sdk::codec::encoder::SolidityABI::<
            SecondMethodCallArgs,
        >::is_dynamic() {
            ::fluentbase_sdk::U256::from(32).to_be_bytes::<32>().to_vec()
        } else {
            ::alloc::vec::Vec::new()
        };
        let mut combined_buf = fluentbase_sdk::codec::bytes::BytesMut::new();
        combined_buf.put_slice(&dynamic_offset);
        combined_buf.put_slice(buf.chunk());
        let args = fluentbase_sdk::codec::encoder::SolidityABI::<
            SecondMethodCallArgs,
        >::decode(&combined_buf.freeze(), 0)?;
        Ok(Self(args))
    }
}
impl ::core::ops::Deref for SecondMethodCall {
    type Target = SecondMethodCallArgs;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
pub type SecondMethodCallTarget = <SecondMethodCall as ::core::ops::Deref>::Target;
pub type SecondMethodReturnArgs = (String, bool);
#[derive(Debug)]
pub struct SecondMethodReturn(SecondMethodReturnArgs);
impl SecondMethodReturn {
    pub fn new(args: SecondMethodReturnArgs) -> Self {
        Self(args)
    }
    pub fn encode(&self) -> fluentbase_sdk::codec::bytes::Bytes {
        let mut buf = fluentbase_sdk::codec::bytes::BytesMut::new();
        fluentbase_sdk::codec::encoder::SolidityABI::encode(
                &(self.0.clone().0, self.0.clone().1),
                &mut buf,
                0,
            )
            .unwrap();
        let encoded_args = buf.freeze();
        let clean_args = if fluentbase_sdk::codec::encoder::SolidityABI::<
            SecondMethodReturnArgs,
        >::is_dynamic() {
            encoded_args[32..].to_vec()
        } else {
            encoded_args.to_vec()
        };
        clean_args.into()
    }
    pub fn decode(
        buf: &impl fluentbase_sdk::codec::bytes::Buf,
    ) -> ::core::result::Result<Self, fluentbase_sdk::codec::CodecError> {
        use fluentbase_sdk::codec::bytes::BufMut;
        let dynamic_offset = if fluentbase_sdk::codec::encoder::SolidityABI::<
            SecondMethodReturnArgs,
        >::is_dynamic() {
            ::fluentbase_sdk::U256::from(32).to_be_bytes::<32>().to_vec()
        } else {
            ::alloc::vec::Vec::new()
        };
        let mut combined_buf = fluentbase_sdk::codec::bytes::BytesMut::new();
        combined_buf.put_slice(&dynamic_offset);
        combined_buf.put_slice(buf.chunk());
        let args = fluentbase_sdk::codec::encoder::SolidityABI::<
            SecondMethodReturnArgs,
        >::decode(&combined_buf.freeze(), 0)?;
        Ok(Self(args))
    }
}
impl ::core::ops::Deref for SecondMethodReturn {
    type Target = SecondMethodReturnArgs;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
pub type SecondMethodReturnTarget = <SecondMethodReturn as ::core::ops::Deref>::Target;
impl<SDK: fluentbase_sdk::SharedAPI> TestContractClient<SDK> {
    pub fn new(sdk: SDK) -> Self {
        Self { sdk }
    }
    pub fn encode_first_method(&self, value: u32) -> fluentbase_sdk::Bytes {
        FirstMethodCall::new((value,)).encode().into()
    }
    pub fn decode_first_method(&self, output: fluentbase_sdk::Bytes) -> (u32,) {
        FirstMethodCall::decode(&output).expect("failed to decode result").0
    }
    pub fn encode_second_method(&self, a: String, b: bool) -> fluentbase_sdk::Bytes {
        SecondMethodCall::new((a, b)).encode().into()
    }
    pub fn decode_second_method(&self, output: fluentbase_sdk::Bytes) -> (String, bool) {
        SecondMethodCall::decode(&output).expect("failed to decode result").0
    }
}
impl<SDK: fluentbase_sdk::SharedAPI> TestContractClient<SDK> {
    pub fn first_method(
        &mut self,
        contract_address: fluentbase_sdk::Address,
        value: fluentbase_sdk::U256,
        gas_limit: u64,
        value: u32,
    ) -> (u32,) {
        use fluentbase_sdk::{TxContextReader, SyscallResult};
        let input = self.encode_first_method(value);
        {
            let context = self.sdk.context();
            if context.tx_value() < value {
                ::core::panic!("client: insufficient funds");
            }
            if context.tx_gas_limit() < gas_limit {
                ::core::panic!("client: insufficient gas");
            }
        }
        let result = self.sdk.call(contract_address, value, &input, Some(gas_limit));
        if !SyscallResult::is_ok(result.status) {
            ::core::panic!("client: call failed");
        }
        self.decode_first_method(result.data)
    }
    pub fn second_method(
        &mut self,
        contract_address: fluentbase_sdk::Address,
        value: fluentbase_sdk::U256,
        gas_limit: u64,
        a: String,
        b: bool,
    ) -> (String, bool) {
        use fluentbase_sdk::{TxContextReader, SyscallResult};
        let input = self.encode_second_method(a, b);
        {
            let context = self.sdk.context();
            if context.tx_value() < value {
                ::core::panic!("client: insufficient funds");
            }
            if context.tx_gas_limit() < gas_limit {
                ::core::panic!("client: insufficient gas");
            }
        }
        let result = self.sdk.call(contract_address, value, &input, Some(gas_limit));
        if !SyscallResult::is_ok(result.status) {
            ::core::panic!("client: call failed");
        }
        self.decode_second_method(result.data)
    }
}
