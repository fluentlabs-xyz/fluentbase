---
source: crates/sdk-derive/derive-core/src/storage.rs
expression: formatted
---
impl PackedConfig {
    /// Number of storage slots used by auto-layout fields.
    pub const SLOTS: usize = Self::calculate_slots();
    /// Creates a new instance at a specific slot and offset.
    pub fn new(slot: fluentbase_sdk::U256, offset: u8) -> Self {
        let mut current_slot = slot;
        let mut current_offset: u8 = offset;
        let is_active_layout = {
            let bytes = <StoragePrimitive<
                bool,
            > as fluentbase_sdk::storage::StorageLayout>::BYTES as u8;
            let slots = <StoragePrimitive<
                bool,
            > as fluentbase_sdk::storage::StorageLayout>::SLOTS;
            if slots == 0 {
                if current_offset + bytes <= 32 {
                    let actual_offset = 32 - current_offset - bytes;
                    let result = (current_slot, actual_offset);
                    current_offset += bytes;
                    result
                } else {
                    current_slot = current_slot + fluentbase_sdk::U256::from(1);
                    let actual_offset = 32 - bytes;
                    current_offset = bytes;
                    (current_slot, actual_offset)
                }
            } else {
                if current_offset > 0 {
                    current_slot = current_slot + fluentbase_sdk::U256::from(1);
                    current_offset = 0;
                }
                let result = (current_slot, 0);
                current_slot = current_slot + fluentbase_sdk::U256::from(slots);
                (result)
            }
        };
        let is_paused_layout = {
            let bytes = <StoragePrimitive<
                bool,
            > as fluentbase_sdk::storage::StorageLayout>::BYTES as u8;
            let slots = <StoragePrimitive<
                bool,
            > as fluentbase_sdk::storage::StorageLayout>::SLOTS;
            if slots == 0 {
                if current_offset + bytes <= 32 {
                    let actual_offset = 32 - current_offset - bytes;
                    let result = (current_slot, actual_offset);
                    current_offset += bytes;
                    result
                } else {
                    current_slot = current_slot + fluentbase_sdk::U256::from(1);
                    let actual_offset = 32 - bytes;
                    current_offset = bytes;
                    (current_slot, actual_offset)
                }
            } else {
                if current_offset > 0 {
                    current_slot = current_slot + fluentbase_sdk::U256::from(1);
                    current_offset = 0;
                }
                let result = (current_slot, 0);
                current_slot = current_slot + fluentbase_sdk::U256::from(slots);
                (result)
            }
        };
        let version_layout = {
            let bytes = <StoragePrimitive<
                u32,
            > as fluentbase_sdk::storage::StorageLayout>::BYTES as u8;
            let slots = <StoragePrimitive<
                u32,
            > as fluentbase_sdk::storage::StorageLayout>::SLOTS;
            if slots == 0 {
                if current_offset + bytes <= 32 {
                    let actual_offset = 32 - current_offset - bytes;
                    let result = (current_slot, actual_offset);
                    current_offset += bytes;
                    result
                } else {
                    current_slot = current_slot + fluentbase_sdk::U256::from(1);
                    let actual_offset = 32 - bytes;
                    current_offset = bytes;
                    (current_slot, actual_offset)
                }
            } else {
                if current_offset > 0 {
                    current_slot = current_slot + fluentbase_sdk::U256::from(1);
                    current_offset = 0;
                }
                let result = (current_slot, 0);
                current_slot = current_slot + fluentbase_sdk::U256::from(slots);
                (result)
            }
        };
        let flags_layout = {
            let bytes = <StoragePrimitive<
                u64,
            > as fluentbase_sdk::storage::StorageLayout>::BYTES as u8;
            let slots = <StoragePrimitive<
                u64,
            > as fluentbase_sdk::storage::StorageLayout>::SLOTS;
            if slots == 0 {
                if current_offset + bytes <= 32 {
                    let actual_offset = 32 - current_offset - bytes;
                    let result = (current_slot, actual_offset);
                    current_offset += bytes;
                    result
                } else {
                    current_slot = current_slot + fluentbase_sdk::U256::from(1);
                    let actual_offset = 32 - bytes;
                    current_offset = bytes;
                    (current_slot, actual_offset)
                }
            } else {
                if current_offset > 0 {
                    current_slot = current_slot + fluentbase_sdk::U256::from(1);
                    current_offset = 0;
                }
                let result = (current_slot, 0);
                current_slot = current_slot + fluentbase_sdk::U256::from(slots);
                (result)
            }
        };
        let owner_layout = {
            let bytes = <StoragePrimitive<
                Address,
            > as fluentbase_sdk::storage::StorageLayout>::BYTES as u8;
            let slots = <StoragePrimitive<
                Address,
            > as fluentbase_sdk::storage::StorageLayout>::SLOTS;
            if slots == 0 {
                if current_offset + bytes <= 32 {
                    let actual_offset = 32 - current_offset - bytes;
                    let result = (current_slot, actual_offset);
                    current_offset += bytes;
                    result
                } else {
                    current_slot = current_slot + fluentbase_sdk::U256::from(1);
                    let actual_offset = 32 - bytes;
                    current_offset = bytes;
                    (current_slot, actual_offset)
                }
            } else {
                if current_offset > 0 {
                    current_slot = current_slot + fluentbase_sdk::U256::from(1);
                    current_offset = 0;
                }
                let result = (current_slot, 0);
                current_slot = current_slot + fluentbase_sdk::U256::from(slots);
                (result)
            }
        };
        Self {
            is_active: <<StoragePrimitive<
                bool,
            > as fluentbase_sdk::storage::StorageLayout>::Descriptor as fluentbase_sdk::storage::StorageDescriptor>::new(
                is_active_layout.0,
                is_active_layout.1,
            ),
            is_paused: <<StoragePrimitive<
                bool,
            > as fluentbase_sdk::storage::StorageLayout>::Descriptor as fluentbase_sdk::storage::StorageDescriptor>::new(
                is_paused_layout.0,
                is_paused_layout.1,
            ),
            version: <<StoragePrimitive<
                u32,
            > as fluentbase_sdk::storage::StorageLayout>::Descriptor as fluentbase_sdk::storage::StorageDescriptor>::new(
                version_layout.0,
                version_layout.1,
            ),
            flags: <<StoragePrimitive<
                u64,
            > as fluentbase_sdk::storage::StorageLayout>::Descriptor as fluentbase_sdk::storage::StorageDescriptor>::new(
                flags_layout.0,
                flags_layout.1,
            ),
            owner: <<StoragePrimitive<
                Address,
            > as fluentbase_sdk::storage::StorageLayout>::Descriptor as fluentbase_sdk::storage::StorageDescriptor>::new(
                owner_layout.0,
                owner_layout.1,
            ),
        }
    }
    const fn calculate_slots() -> usize {
        let mut current_slot: usize = 0;
        let mut current_offset: usize = 0;
        {
            let bytes = <StoragePrimitive<
                bool,
            > as fluentbase_sdk::storage::StorageLayout>::BYTES;
            let slots = <StoragePrimitive<
                bool,
            > as fluentbase_sdk::storage::StorageLayout>::SLOTS;
            if slots == 0 {
                if current_offset + bytes <= 32 {
                    current_offset += bytes;
                } else {
                    current_slot += 1;
                    current_offset = bytes;
                }
            } else {
                if current_offset > 0 {
                    current_slot += 1;
                    current_offset = 0;
                }
                current_slot += slots;
                current_offset = 0;
            }
        }
        {
            let bytes = <StoragePrimitive<
                bool,
            > as fluentbase_sdk::storage::StorageLayout>::BYTES;
            let slots = <StoragePrimitive<
                bool,
            > as fluentbase_sdk::storage::StorageLayout>::SLOTS;
            if slots == 0 {
                if current_offset + bytes <= 32 {
                    current_offset += bytes;
                } else {
                    current_slot += 1;
                    current_offset = bytes;
                }
            } else {
                if current_offset > 0 {
                    current_slot += 1;
                    current_offset = 0;
                }
                current_slot += slots;
                current_offset = 0;
            }
        }
        {
            let bytes = <StoragePrimitive<
                u32,
            > as fluentbase_sdk::storage::StorageLayout>::BYTES;
            let slots = <StoragePrimitive<
                u32,
            > as fluentbase_sdk::storage::StorageLayout>::SLOTS;
            if slots == 0 {
                if current_offset + bytes <= 32 {
                    current_offset += bytes;
                } else {
                    current_slot += 1;
                    current_offset = bytes;
                }
            } else {
                if current_offset > 0 {
                    current_slot += 1;
                    current_offset = 0;
                }
                current_slot += slots;
                current_offset = 0;
            }
        }
        {
            let bytes = <StoragePrimitive<
                u64,
            > as fluentbase_sdk::storage::StorageLayout>::BYTES;
            let slots = <StoragePrimitive<
                u64,
            > as fluentbase_sdk::storage::StorageLayout>::SLOTS;
            if slots == 0 {
                if current_offset + bytes <= 32 {
                    current_offset += bytes;
                } else {
                    current_slot += 1;
                    current_offset = bytes;
                }
            } else {
                if current_offset > 0 {
                    current_slot += 1;
                    current_offset = 0;
                }
                current_slot += slots;
                current_offset = 0;
            }
        }
        {
            let bytes = <StoragePrimitive<
                Address,
            > as fluentbase_sdk::storage::StorageLayout>::BYTES;
            let slots = <StoragePrimitive<
                Address,
            > as fluentbase_sdk::storage::StorageLayout>::SLOTS;
            if slots == 0 {
                if current_offset + bytes <= 32 {
                    current_offset += bytes;
                } else {
                    current_slot += 1;
                    current_offset = bytes;
                }
            } else {
                if current_offset > 0 {
                    current_slot += 1;
                    current_offset = 0;
                }
                current_slot += slots;
                current_offset = 0;
            }
        }
        if current_offset > 0 { current_slot + 1 } else { current_slot }
    }
    const fn calculate_bytes() -> usize {
        let mut total_bytes: usize = 0;
        total_bytes
            += <StoragePrimitive<bool> as fluentbase_sdk::storage::StorageLayout>::BYTES;
        total_bytes
            += <StoragePrimitive<bool> as fluentbase_sdk::storage::StorageLayout>::BYTES;
        total_bytes
            += <StoragePrimitive<u32> as fluentbase_sdk::storage::StorageLayout>::BYTES;
        total_bytes
            += <StoragePrimitive<u64> as fluentbase_sdk::storage::StorageLayout>::BYTES;
        total_bytes
            += <StoragePrimitive<
                Address,
            > as fluentbase_sdk::storage::StorageLayout>::BYTES;
        total_bytes
    }
    ///Returns an accessor for the `is_active` storage field.
    #[inline]
    pub fn is_active_accessor(
        &self,
    ) -> <StoragePrimitive<bool> as fluentbase_sdk::storage::StorageLayout>::Accessor {
        <StoragePrimitive<
            bool,
        > as fluentbase_sdk::storage::StorageLayout>::access(self.is_active)
    }
    ///Returns an accessor for the `is_paused` storage field.
    #[inline]
    pub fn is_paused_accessor(
        &self,
    ) -> <StoragePrimitive<bool> as fluentbase_sdk::storage::StorageLayout>::Accessor {
        <StoragePrimitive<
            bool,
        > as fluentbase_sdk::storage::StorageLayout>::access(self.is_paused)
    }
    ///Returns an accessor for the `version` storage field.
    #[inline]
    pub fn version_accessor(
        &self,
    ) -> <StoragePrimitive<u32> as fluentbase_sdk::storage::StorageLayout>::Accessor {
        <StoragePrimitive<
            u32,
        > as fluentbase_sdk::storage::StorageLayout>::access(self.version)
    }
    ///Returns an accessor for the `flags` storage field.
    #[inline]
    pub fn flags_accessor(
        &self,
    ) -> <StoragePrimitive<u64> as fluentbase_sdk::storage::StorageLayout>::Accessor {
        <StoragePrimitive<
            u64,
        > as fluentbase_sdk::storage::StorageLayout>::access(self.flags)
    }
    ///Returns an accessor for the `owner` storage field.
    #[inline]
    pub fn owner_accessor(
        &self,
    ) -> <StoragePrimitive<
        Address,
    > as fluentbase_sdk::storage::StorageLayout>::Accessor {
        <StoragePrimitive<
            Address,
        > as fluentbase_sdk::storage::StorageLayout>::access(self.owner)
    }
}
impl Copy for PackedConfig {}
impl Clone for PackedConfig {
    fn clone(&self) -> Self {
        *self
    }
}
impl fluentbase_sdk::storage::StorageDescriptor for PackedConfig {
    fn new(slot: fluentbase_sdk::U256, offset: u8) -> Self {
        Self::new(slot, offset)
    }
    fn slot(&self) -> fluentbase_sdk::U256 {
        self.is_active.slot()
    }
    fn offset(&self) -> u8 {
        0
    }
}
impl fluentbase_sdk::storage::StorageLayout for PackedConfig {
    type Descriptor = Self;
    type Accessor = Self;
    const BYTES: usize = Self::calculate_bytes();
    const SLOTS: usize = Self::calculate_slots();
    fn access(descriptor: Self::Descriptor) -> Self::Accessor {
        descriptor
    }
}
