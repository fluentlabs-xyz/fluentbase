use chrono::Local;
use convert_case::{Case, Casing};
use serde_json::Value;
use std::{collections::HashSet, fs, path::Path};

const INTERFACE_TEMPLATE: &str = r#"// SPDX-License-Identifier: MIT
// This file is auto-generated
// DO NOT EDIT THIS FILE MANUALLY!
// Source contract: {contract_name}
// Generated at: {timestamp}

pragma solidity ^0.8.0;

{imports}
interface I{contract_name} {
{structs}
{functions}
}
"#;

const STRUCT_TEMPLATE: &str = r#"    struct {name} {
{fields}
    }"#;

const FUNCTION_TEMPLATE: &str = r#"    function {name}({params}) external{mutability}{returns};"#;

#[derive(Debug)]
pub struct ContractArtifacts {
    pub base_name: String,
    pub abi_content: String,
    pub interface_content: String,
}

#[derive(Debug)]
struct SolidityFunction {
    name: String,
    params: Vec<SolidityParameter>,
    returns: Vec<SolidityParameter>,
    is_view: bool,
    is_payable: bool,
}

#[derive(Debug)]
struct SolidityParameter {
    name: String,
    type_name: String,
    location: Option<DataLocation>,
}

#[allow(dead_code)]
#[derive(Debug, Clone, Copy)]
enum DataLocation {
    Memory,
    Calldata,
    Storage,
}

impl ContractArtifacts {
    pub fn new(name: &str, abi: &[Value]) -> Self {
        let generator = SolidityInterfaceGenerator::new(name);
        Self {
            base_name: name.to_case(Case::Pascal),
            abi_content: serde_json::to_string_pretty(abi).expect("Failed to serialize ABI"),
            interface_content: generator.generate_from_abi(abi),
        }
    }

    pub fn save_to_dir(&self, dir: &Path) -> std::io::Result<()> {
        let contract_dir = dir.join(&self.base_name);
        fs::create_dir_all(&contract_dir)?;

        fs::write(
            contract_dir.join(format!("{}.abi.json", self.base_name)),
            &self.abi_content,
        )?;

        fs::write(
            contract_dir.join(format!("I{}.sol", self.base_name)),
            &self.interface_content,
        )?;

        Ok(())
    }
}

#[derive(Debug, Clone)]
pub struct SolidityInterfaceGenerator {
    contract_name: String,
    imports: Vec<String>,
}

impl SolidityInterfaceGenerator {
    pub fn new(name: &str) -> Self {
        Self {
            contract_name: name.to_case(Case::Pascal),
            imports: Vec::new(),
        }
    }

    pub fn generate_from_abi(&self, abi: &[Value]) -> String {
        let imports = self
            .imports
            .iter()
            .map(|import| format!("import \"{}\";", import))
            .collect::<Vec<_>>()
            .join("\n");

        let structs = self.collect_and_generate_structs(abi);
        let functions = self.generate_functions(abi);

        INTERFACE_TEMPLATE
            .replace("{contract_name}", &self.contract_name)
            .replace(
                "{timestamp}",
                &Local::now().format("%Y-%m-%d %H:%M:%S").to_string(),
            )
            .replace("{imports}", &imports)
            .replace("{structs}", &structs)
            .replace("{functions}", &functions)
    }

    fn collect_and_generate_structs(&self, abi: &[Value]) -> String {
        let struct_names = self.collect_struct_names(abi);
        let struct_definitions: Vec<String> = struct_names
            .iter()
            .filter_map(|name| self.generate_struct_definition(name))
            .collect();

        if struct_definitions.is_empty() {
            String::new()
        } else {
            format!("{}\n", struct_definitions.join("\n\n"))
        }
    }

    fn collect_struct_names(&self, abi: &[Value]) -> HashSet<String> {
        let mut seen_structs = HashSet::new();

        for func in abi {
            if let Some(inputs) = func.get("inputs").and_then(Value::as_array) {
                Self::collect_struct_types(inputs, &mut seen_structs);
            }
            if let Some(outputs) = func.get("outputs").and_then(Value::as_array) {
                Self::collect_struct_types(outputs, &mut seen_structs);
            }
        }

        seen_structs
    }

    fn collect_struct_types(params: &[Value], seen_structs: &mut HashSet<String>) {
        for param in params {
            if param["type"] == "tuple" {
                if let Some(components) = param.get("components").and_then(Value::as_array) {
                    Self::collect_struct_types(components, seen_structs);

                    if let Some(name) = param
                        .get("internalType")
                        .and_then(Value::as_str)
                        .filter(|s| s.starts_with("struct "))
                    {
                        seen_structs.insert(name[7..].to_string());
                    }
                }
            }
        }
    }

    fn generate_struct_definition(&self, struct_name: &str) -> Option<String> {
        let out_dir = std::env::var("OUT_DIR").ok()?;
        let file_path = Path::new(&out_dir)
            .join("solidity_abi")
            .join(format!("{}.json", struct_name));

        let content = fs::read_to_string(file_path).ok()?;
        let def: Value = serde_json::from_str(&content).ok()?;
        let components = def.get("components")?.as_array()?;

        let fields = components
            .iter()
            .map(|component| {
                let name = component["name"].as_str().unwrap();
                let type_str = Self::get_type_string(component);
                format!("        {} {};", type_str, name)
            })
            .collect::<Vec<_>>()
            .join("\n");

        Some(
            STRUCT_TEMPLATE
                .replace("{name}", struct_name)
                .replace("{fields}", &fields),
        )
    }

    fn generate_functions(&self, abi: &[Value]) -> String {
        abi.iter()
            .filter_map(|func| self.parse_function(func))
            .map(|func| self.format_function(&func))
            .collect::<Vec<_>>()
            .join("\n")
    }

    fn parse_function(&self, func: &Value) -> Option<SolidityFunction> {
        let name = func.get("name")?.as_str()?.to_string();
        let inputs = func.get("inputs")?.as_array()?;
        let outputs = func.get("outputs")?.as_array()?;
        let state_mutability = func.get("stateMutability").and_then(Value::as_str);

        let params = inputs
            .iter()
            .map(|param| self.parse_parameter(param))
            .collect();

        let returns = outputs
            .iter()
            .map(|param| self.parse_parameter(param))
            .collect();

        Some(SolidityFunction {
            name,
            params,
            returns,
            is_view: state_mutability == Some("view"),
            is_payable: state_mutability == Some("payable"),
        })
    }

    fn parse_parameter(&self, param: &Value) -> SolidityParameter {
        let name = param["name"].as_str().unwrap_or("").to_string();
        let type_str = Self::get_type_string(param);
        let location = self.get_data_location(param);

        SolidityParameter {
            name,
            type_name: type_str,
            location,
        }
    }

    fn format_function(&self, func: &SolidityFunction) -> String {
        let params = func
            .params
            .iter()
            .map(|param| self.format_parameter(param, true))
            .collect::<Vec<_>>()
            .join(", ");

        let mutability = if func.is_payable {
            " payable"
        } else if func.is_view {
            " view"
        } else {
            ""
        };

        let returns = if func.returns.is_empty() {
            String::new()
        } else {
            let return_params = func
                .returns
                .iter()
                .map(|param| self.format_parameter(param, false))
                .collect::<Vec<_>>()
                .join(", ");
            format!(" returns ({})", return_params)
        };

        FUNCTION_TEMPLATE
            .replace("{name}", &func.name)
            .replace("{params}", &params)
            .replace("{mutability}", mutability)
            .replace("{returns}", &returns)
    }

    fn format_parameter(&self, param: &SolidityParameter, is_input: bool) -> String {
        let location = param.location.map_or(String::new(), |loc| {
            format!(
                " {}",
                match (is_input, loc) {
                    (true, DataLocation::Memory) => "memory",
                    (true, DataLocation::Calldata) => "calldata",
                    (false, _) => "memory",
                    (_, DataLocation::Storage) => "storage",
                }
            )
        });

        if param.name.is_empty() {
            format!("{}{}", param.type_name, location)
        } else {
            format!("{}{} {}", param.type_name, location, param.name)
        }
    }

    fn get_type_string(param: &Value) -> String {
        let type_str = param["type"].as_str().unwrap();

        if type_str == "tuple" {
            if let Some(internal_type) = param
                .get("internalType")
                .and_then(Value::as_str)
                .filter(|s| s.starts_with("struct "))
            {
                return internal_type[7..].to_string();
            }

            let components = param["components"].as_array().unwrap();
            let component_types = components
                .iter()
                .map(Self::get_type_string)
                .collect::<Vec<_>>();

            format!("({})", component_types.join(","))
        } else {
            type_str.to_string()
        }
    }

    fn get_data_location(&self, param: &Value) -> Option<DataLocation> {
        let type_str = param["type"].as_str().unwrap();
        match type_str {
            "string" | "bytes" => Some(DataLocation::Calldata),
            "tuple" => Some(DataLocation::Memory),
            _ if type_str.ends_with("[]") => Some(DataLocation::Memory),
            _ => None,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use serde_json::json;
    use serial_test::serial;
    use tempfile::TempDir;

    #[test]
    fn test_simple_function() {
        let abi = vec![json!({
            "name": "greeting",
            "type": "function",
            "stateMutability": "view",
            "inputs": [
                {"name": "name", "type": "string"}
            ],
            "outputs": [
                {"name": "result", "type": "string"}
            ]
        })];

        let generator = SolidityInterfaceGenerator::new("Greeter");
        let interface = generator.generate_from_abi(&abi);

        assert!(interface.contains("interface IGreeter {"));
        assert!(interface.contains(
            "function greeting(string calldata name) external view returns (string memory result);"
        ));
    }

    #[test]
    #[serial]
    fn test_struct_generation() {
        let temp_dir = TempDir::new().unwrap();
        std::env::set_var("OUT_DIR", temp_dir.path());

        let abi_dir = temp_dir.path().join("solidity_abi");
        fs::create_dir_all(&abi_dir).unwrap();

        let point_abi = json!({
            "type": "tuple",
            "components": [
                {"name": "x", "type": "uint64"},
                {"name": "y", "type": "uint256"}
            ]
        });

        fs::write(
            abi_dir.join("Point.json"),
            serde_json::to_string_pretty(&point_abi).unwrap(),
        )
        .unwrap();

        let abi = vec![json!({
            "name": "setPoint",
            "type": "function",
            "inputs": [{
                "name": "point",
                "type": "tuple",
                "internalType": "struct Point",
                "components": [
                    {"name": "x", "type": "uint64"},
                    {"name": "y", "type": "uint256"}
                ]
            }],
            "outputs": []
        })];

        let generator = SolidityInterfaceGenerator::new("PointManager");
        let interface = generator.generate_from_abi(&abi);

        assert!(interface.contains("struct Point {"));
        assert!(interface.contains("uint64 x;"));
        assert!(interface.contains("uint256 y;"));
        assert!(interface.contains("function setPoint(Point memory point) external;"));
    }

    #[test]
    #[serial]
    fn test_nested_structs() {
        let temp_dir = TempDir::new().unwrap();
        std::env::set_var("OUT_DIR", temp_dir.path());

        let abi_dir = temp_dir.path().join("solidity_abi");
        fs::create_dir_all(&abi_dir).unwrap();

        let point_abi = json!({
            "type": "tuple",
            "components": [
                {"name": "x", "type": "uint64"},
                {"name": "y", "type": "uint256"}
            ]
        });

        let complex_point_abi = json!({
            "type": "tuple",
            "components": [
                {
                    "name": "point",
                    "type": "tuple",
                    "internalType": "struct Point",
                    "components": [
                        {"name": "x", "type": "uint64"},
                        {"name": "y", "type": "uint256"}
                    ]
                },
                {"name": "description", "type": "string"},
                {"name": "active", "type": "bool"}
            ]
        });

        fs::write(
            abi_dir.join("Point.json"),
            serde_json::to_string_pretty(&point_abi).unwrap(),
        )
        .unwrap();

        fs::write(
            abi_dir.join("ComplexPoint.json"),
            serde_json::to_string_pretty(&complex_point_abi).unwrap(),
        )
        .unwrap();

        let abi = vec![json!({
            "name": "processPoint",
            "type": "function",
            "inputs": [{
                "name": "complexPoint",
                "type": "tuple",
                "internalType": "struct ComplexPoint",
                "components": [
                    {
                        "name": "point",
                        "type": "tuple",
                        "internalType": "struct Point",
                        "components": [
                            {"name": "x", "type": "uint64"},
                            {"name": "y", "type": "uint256"}
                        ]
                    },
                    {"name": "description", "type": "string"},
                    {"name": "active", "type": "bool"}
                ]
            }],
            "outputs": [{"name": "success", "type": "bool"}]
        })];

        let generator = SolidityInterfaceGenerator::new("PointProcessor");
        let interface = generator.generate_from_abi(&abi);

        assert!(interface.contains("struct Point {"));
        assert!(interface.contains("struct ComplexPoint {"));

        assert!(interface.contains("uint64 x;"));
        assert!(interface.contains("uint256 y;"));
        assert!(interface.contains("Point point;"));
        assert!(interface.contains("string description;"));
        assert!(interface.contains("bool active;"));

        assert!(interface.contains("function processPoint(ComplexPoint memory complexPoint) external returns (bool success);"));
    }

    #[test]
    fn test_array_types() {
        let abi = vec![json!({
            "name": "processArrays",
            "type": "function",
            "inputs": [
                {"name": "numbers", "type": "uint256[]"},
                {"name": "names", "type": "string[]"}
            ],
            "outputs": [
                {"name": "result", "type": "bool[]"}
            ]
        })];

        let generator = SolidityInterfaceGenerator::new("ArrayProcessor");
        let interface = generator.generate_from_abi(&abi);

        assert!(interface.contains(
            "function processArrays(uint256[] memory numbers, string[] memory names) external returns (bool[] memory result);"
        ));
    }

    #[test]
    fn test_anonymous_tuple() {
        let abi = vec![json!({
            "name": "processTuple",
            "type": "function",
            "inputs": [{
                "name": "data",
                "type": "tuple",
                "components": [
                    {"name": "value", "type": "uint256"},
                    {"name": "flag", "type": "bool"}
                ]
            }],
            "outputs": []
        })];

        let generator = SolidityInterfaceGenerator::new("TupleProcessor");
        let interface = generator.generate_from_abi(&abi);

        assert!(interface.contains("function processTuple((uint256,bool) memory data) external;"));
    }

    #[test]
    #[serial]
    fn test_artifacts_saving() {
        let temp_dir = TempDir::new().unwrap();

        let abi = vec![json!({
            "name": "test",
            "type": "function",
            "inputs": [],
            "outputs": []
        })];

        let artifacts = ContractArtifacts::new("TestContract", &abi);
        artifacts.save_to_dir(temp_dir.path()).unwrap();

        let contract_dir = temp_dir.path().join("TestContract");
        assert!(contract_dir.exists());
        assert!(contract_dir.join("TestContract.abi.json").exists());
        assert!(contract_dir.join("ITestContract.sol").exists());
    }
}
