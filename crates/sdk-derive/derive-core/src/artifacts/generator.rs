use anyhow::Result;
use convert_case::{Case, Casing};
use serde_json::{json, Value};
use std::collections::HashSet;

const INTERFACE_TEMPLATE: &str = r"// SPDX-License-Identifier: MIT
// This file is auto-generated
// DO NOT EDIT THIS FILE MANUALLY!
// Source contract: {{contract_name}}

pragma solidity ^0.8.0;

interface I{{contract_name}} {
{{structs}}
{{functions}}
}";

#[derive(Debug)]
struct ParsedSolidityFn {
    name: String,
    params: Vec<Parameter>,
    returns: Vec<Parameter>,
    mutability: StateMutability,
}

#[derive(Debug)]
struct Parameter {
    name: String,
    ty: String,
    location: Option<DataLocation>,
    internal_type: Option<String>,
}

#[derive(Debug, PartialEq)]
enum StateMutability {
    Pure,
    View,
    Payable,
    NonPayable,
}

#[derive(Debug, Clone, Copy)]
enum DataLocation {
    Memory,
    Calldata,
}

pub fn generate_sol_interface(contract_name: &str, functions_abi: &[Value]) -> Result<String> {
    let mut seen_structs = HashSet::new();
    let mut struct_definitions = Vec::new();
    let functions = functions_abi
        .iter()
        .filter(|entry| entry["type"] == "function")
        .filter_map(generate_function)
        .collect::<Vec<_>>()
        .join("\n");

    for entry in functions_abi {
        if entry["type"] == "function" {
            if let Some(inputs) = entry.get("inputs").and_then(Value::as_array) {
                collect_structs(inputs, &mut seen_structs, &mut struct_definitions);
            }
            if let Some(outputs) = entry.get("outputs").and_then(Value::as_array) {
                collect_structs(outputs, &mut seen_structs, &mut struct_definitions);
            }
        }
    }

    let structs = if struct_definitions.is_empty() {
        String::new()
    } else {
        format!("{}\n", struct_definitions.join("\n\n"))
    };

    Ok(INTERFACE_TEMPLATE
        .replace("{{contract_name}}", &contract_name.to_case(Case::Pascal))
        .replace("{{structs}}", &structs)
        .replace("{{functions}}", &functions))
}

fn generate_function(entry: &Value) -> Option<String> {
    let parsed = parse_function(entry)?;

    let params = parsed
        .params
        .iter()
        .map(format_parameter)
        .collect::<Vec<_>>()
        .join(", ");

    let returns = if parsed.returns.is_empty() {
        String::new()
    } else {
        let return_params = parsed
            .returns
            .iter()
            .map(format_parameter)
            .collect::<Vec<_>>()
            .join(", ");
        format!(" returns ({return_params})")
    };

    let mutability = match parsed.mutability {
        StateMutability::Pure => " pure",
        StateMutability::View => " view",
        StateMutability::Payable => " payable",
        StateMutability::NonPayable => "",
    };

    Some(format!(
        "    function {}({}) external{}{};",
        parsed.name, params, mutability, returns
    ))
}

fn parse_function(entry: &Value) -> Option<ParsedSolidityFn> {
    let name = entry.get("name")?.as_str()?.to_string();
    let inputs = entry.get("inputs").and_then(Value::as_array)?;
    let outputs = entry.get("outputs").and_then(Value::as_array)?;
    let state_mutability = entry.get("stateMutability").and_then(Value::as_str)?;

    let mutability = match state_mutability {
        "pure" => StateMutability::Pure,
        "view" => StateMutability::View,
        "payable" => StateMutability::Payable,
        _ => StateMutability::NonPayable,
    };

    let params = inputs.iter().map(parse_parameter).collect();
    let returns = outputs.iter().map(parse_parameter).collect();

    Some(ParsedSolidityFn {
        name,
        params,
        returns,
        mutability,
    })
}

fn parse_parameter(param: &Value) -> Parameter {
    let name = param["name"].as_str().unwrap_or("").to_string();
    let internal_type = param
        .get("internalType")
        .and_then(Value::as_str)
        .map(std::string::ToString::to_string);
    let ty = format_sol_type(param);
    let location = get_data_location(&ty, &internal_type);

    Parameter {
        name,
        ty,
        location,
        internal_type,
    }
}

fn format_parameter(param: &Parameter) -> String {
    let ty = if let Some(internal_type) = &param.internal_type {
        if let Some(stripped) = internal_type.strip_prefix("struct ") {
            stripped.to_string()
        } else {
            param.ty.clone()
        }
    } else {
        param.ty.clone()
    };

    let location = param.location.map_or(String::new(), |loc| {
        format!(
            " {}",
            match loc {
                DataLocation::Memory => "memory",
                DataLocation::Calldata => "calldata",
            }
        )
    });

    if param.name.is_empty() {
        format!("{ty}{location}")
    } else {
        format!("{}{} {}", ty, location, param.name)
    }
}

fn format_sol_type(param: &Value) -> String {
    let param_type = param["type"].as_str().unwrap_or("unknown");

    if param_type == "tuple" {
        if let Some(internal_type) = param.get("internalType").and_then(Value::as_str) {
            if let Some(stripped) = internal_type.strip_prefix("struct ") {
                return stripped.to_string();
            }
        }

        let components = param["components"].as_array().unwrap();
        let component_types = components
            .iter()
            .map(format_sol_type)
            .collect::<Vec<_>>()
            .join(",");

        format!("({component_types})")
    } else if let Some(base_type) = param_type.strip_suffix("[]") {
        let formatted_base = format_sol_type(&json!({ "type": base_type }));
        format!("{formatted_base}[]")
    } else {
        param_type.to_string()
    }
}

fn get_data_location(ty: &str, internal_type: &Option<String>) -> Option<DataLocation> {
    match (ty, internal_type) {
        (_, Some(t)) if t.starts_with("struct ") => Some(DataLocation::Memory),
        ("string" | "bytes", _) => Some(DataLocation::Calldata),
        (t, _) if t.ends_with("[]") || t.contains("tuple") => Some(DataLocation::Memory),
        _ => None,
    }
}

fn collect_structs(params: &[Value], seen: &mut HashSet<String>, structs: &mut Vec<String>) {
    for param in params {
        if param["type"] == "tuple" {
            if let Some(internal_type) = param.get("internalType").and_then(Value::as_str) {
                if let Some(struct_name) = internal_type.strip_prefix("struct ") {
                    if seen.insert(struct_name.to_string()) {
                        if let Some(components) = param.get("components").and_then(Value::as_array)
                        {
                            let fields = components
                                .iter()
                                .map(|field| {
                                    let field_name = field["name"].as_str().unwrap_or("_");
                                    let field_type = format_sol_type(field);
                                    format!("        {field_type} {field_name};")
                                })
                                .collect::<Vec<_>>()
                                .join("\n");

                            structs.push(format!("    struct {struct_name} {{\n{fields}\n    }}"));

                            collect_structs(components, seen, structs);
                        }
                    }
                }
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use serde_json::json;

    #[test]
    fn test_complex_struct() {
        let abi = vec![json!({
            "name": "setUserInfo",
            "type": "function",
            "inputs": [{
                "name": "info",
                "type": "tuple",
                "internalType": "struct UserInfo",
                "components": [
                    {"name": "name", "type": "string"},
                    {"name": "age", "type": "uint8"},
                    {
                        "name": "address",
                        "type": "tuple",
                        "internalType": "struct Address",
                        "components": [
                            {"name": "city", "type": "string"},
                            {"name": "country", "type": "string"}
                        ]
                    }
                ]
            }],
            "outputs": [],
            "stateMutability": "nonpayable"
        })];

        let interface = generate_sol_interface("UserRegistry", &abi).unwrap();

        println!("Generated interface:\n{}", interface);

        assert!(interface.contains("struct Address {"));
        assert!(interface.contains("struct UserInfo {"));
        assert!(interface.contains("function setUserInfo(UserInfo memory info) external;"));
    }

    #[test]
    fn test_simple_function() {
        let abi = vec![json!({
            "name": "transfer",
            "type": "function",
            "inputs": [
                {"name": "to", "type": "address"},
                {"name": "amount", "type": "uint256"}
            ],
            "outputs": [{"name": "success", "type": "bool"}],
            "stateMutability": "nonpayable"
        })];

        let interface = generate_sol_interface("Token", &abi).unwrap();
        assert!(interface.contains(
            "function transfer(address to, uint256 amount) external returns (bool success);"
        ));
    }
}
